#!/bin/bash

# Check if tput exists and use it for standard color assignment, otherwise fall back to ANSI codes
if command -v tput >/dev/null 2>&1 && tput colors >/dev/null 2>&1; then
    # Use tput for more standard color assignment
    BLACK="\[$(tput setaf 0)\]"
    BLACK_B="\[$(tput bold)$(tput setaf 0)\]"
    RED="\[$(tput setaf 1)\]"
    RED_B="\[$(tput bold)$(tput setaf 1)\]"
    GREEN="\[$(tput setaf 2)\]"
    GREEN_B="\[$(tput bold)$(tput setaf 2)\]"
    YELLOW="\[$(tput setaf 3)\]"
    YELLOW_B="\[$(tput bold)$(tput setaf 3)\]"
    BLUE="\[$(tput setaf 4)\]"
    BLUE_B="\[$(tput bold)$(tput setaf 4)\]"
    PURPLE="\[$(tput setaf 5)\]"
    PURPLE_B="\[$(tput bold)$(tput setaf 5)\]"
    CYAN="\[$(tput setaf 6)\]"
    CYAN_B="\[$(tput bold)$(tput setaf 6)\]"
    WHITE="\[$(tput setaf 7)\]"
    WHITE_B="\[$(tput bold)$(tput setaf 7)\]"
    CLEAR="\[$(tput sgr0)\]"
else
    # Fall back to ANSI escape codes
    BLACK="\[\033[0;30m\]"
    BLACK_B="\[\033[1;30m\]"
    RED="\[\033[0;31m\]"
    RED_B="\[\033[1;31m\]"
    GREEN="\[\033[0;32m\]"
    GREEN_B="\[\033[1;32m\]"
    YELLOW="\[\033[0;33m\]"
    YELLOW_B="\[\033[1;33m\]"
    BLUE="\[\033[0;34m\]"
    BLUE_B="\[\033[1;34m\]"
    PURPLE="\[\033[0;35m\]"
    PURPLE_B="\[\033[1;35m\]"
    CYAN="\[\033[0;36m\]"
    CYAN_B="\[\033[1;36m\]"
    WHITE="\[\033[0;37m\]"
    WHITE_B="\[\033[1;37m\]"
    CLEAR="\[\033[0m\]"
fi

TTY=$(/usr/bin/basename $(/usr/bin/tty))
SSH_WORD="${YELLOW_B}ssh"

#PS1_HOSTNAME=${HOSTNAME}
PS1_HOSTNAME="mbp"

PS1_PWD=$(pwd)

$(echo $TTY| grep '[^0-9]' >/dev/null)
IS_PTY=$?

# Source git prompt script
case "${OSTYPE}" in
    linux*)
        source /usr/lib/git-core/git-sh-prompt
        ;;
    darwin*)
        source /Library/Developer/CommandLineTools/usr/share/git-core/git-prompt.sh
        ;;
esac

# Configure git prompt options (optional)
export GIT_PS1_SHOWDIRTYSTATE=1     # Show * for unstaged changes, + for staged changes
export GIT_PS1_SHOWSTASHSTATE=1     # Show $ when something is stashed
export GIT_PS1_SHOWUNTRACKEDFILES=1 # Show % when there are untracked files
export GIT_PS1_SHOWUPSTREAM="auto"  # Show < > = for behind/ahead/diverged from upstream
export GIT_PS1_SHOWCOLORHINTS=1     # Enable colored hints for dirty state

# Additional color customization options
export GIT_PS1_DESCRIBE_STYLE="branch"  # Show branch name or describe output
export GIT_PS1_HIDE_IF_PWD_IGNORED=1    # Hide git info in ignored directories

if [ "`id -u`" -eq 0 ]; then # user is root
	if [ "$SSH_TTY" != "" ]; then # we are SSH'd in
		PS1="${WHITE_B}[${WHITE}${SSH_WORD}${WHITE_B}!${RED}\u${WHITE_B}@${CLEAR}${PS1_HOSTNAME}${WHITE_B}:${CLEAR}\W\$(__git_ps1 ' (%s) ')${WHITE_B}]${RED}#${CLEAR} "
	elif [ "$SSH_TTY" = "" ] && [ "$IS_PTY" -eq 1 ]; then # terminal is a pty
		PS1="${WHITE_B}[${RED}\u${WHITE_B}@${CLEAR}${PS1_HOSTNAME}${WHITE_B}:${CLEAR}\W\$(__git_ps1 ' (%s) ')${WHITE_B}]${RED}#${CLEAR} "
	else # likely a standard virtual terminal or a serial terminal
		PS1="${WHITE_B}[${WHITE}${TTY}${WHITE_B}!${RED}\u${WHITE_B}@${CLEAR}${PS1_HOSTNAME}${WHITE_B}:${CLEAR}\W\$(__git_ps1 ' (%s) ')${WHITE_B}]${RED}#${CLEAR} "
	fi
else # user is not root
	if [ "$SSH_TTY" != "" ]; then # we are SSH'd in
		PS1="${WHITE_B}[${WHITE}${SSH_WORD}${WHITE_B}!${CYAN}\u${WHITE_B}@${CLEAR}${PS1_HOSTNAME}${WHITE_B}:${CLEAR}\W\$(__git_ps1 ' (%s) ')${WHITE_B}]${CYAN}\$${CLEAR} "
	elif [ "$SSH_TTY" = "" ] && [ "$IS_PTY" -eq 1 ]; then # terminal is a pty
		PS1="${WHITE_B}[${CYAN}\u${WHITE_B}@${CLEAR}${PS1_HOSTNAME}${WHITE_B}:${CLEAR}\W\$(__git_ps1 ' (%s) ')${WHITE_B}]${CYAN}\$${CLEAR} "
	else # likely a standard virtual terminal or a serial terminal
		PS1="${WHITE_B}[${WHITE}${TTY}${WHITE_B}!${CYAN}\u${WHITE_B}@${CLEAR}${PS1_HOSTNAME}${WHITE_B}:${CLEAR}\W\$(__git_ps1 ' (%s) ')${WHITE_B}]${CYAN}\$${CLEAR} "
	fi
fi
